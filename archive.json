{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-02-04T00:42:18.731830+00:00",
  "repo": "pmeenan/i-d-compression-dictionary",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOJ1PnBs5unTr8",
      "title": "Wildcard matching",
      "url": "https://github.com/pmeenan/i-d-compression-dictionary/issues/1",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "For what it's worth, I like Roy's idea of prefix+suffix matching in place of arbitrary wildcards.  Pattern matching is more expensive than simple prefix/suffix matches.\r\n\r\nAlso, \"*\" is a valid path character in HTTP.  Maybe that was unwise, but that's what RFC 3986 says.  Probably not a big deal (you can avoid using it if you plan to use this feature), but still.",
      "createdAt": "2023-08-17T22:45:12Z",
      "updatedAt": "2023-09-20T20:05:08Z",
      "closedAt": "2023-09-20T20:05:08Z",
      "comments": [
        {
          "author": "pmeenan",
          "authorAssociation": "OWNER",
          "body": "[Original listserv response](https://lists.w3.org/Archives/Public/ietf-http-wg/2023JulSep/0130.html) from @royfielding:\r\n\r\nUsing * as a wildcard in arbitrary URL references is a foot gun. It would make more sense to have two attributes, prefix and suffix, and have them only match within the URL path (i.e., exclude the origin and query portions, preventing matches on full URIs or user-supplied query parameters). That is far more likely to get right than allowing things like \"//example.com/*/*/*/*/****\"",
          "createdAt": "2023-08-18T16:48:13Z",
          "updatedAt": "2023-08-18T16:48:13Z"
        },
        {
          "author": "pmeenan",
          "authorAssociation": "OWNER",
          "body": "The origin is already excluded from being configurable. There is some discussion about only supporting relative paths but allowing for full URLs just made it easier to reference the existing URL RFC without having to re-define just the parts we need to support.\r\n\r\nQuery params can't necessarily be excluded and some sites are going to want to allow for either fixed query param matching or wildcard (and maybe for both the static and dynamic use case).  Allowing for * allows for some flexibility in site URL structure while still keeping the matching relatively simple and without the complexity of [URLPattern](\r\nhttps://github.com/WICG/urlpattern/blob/main/mdn-drafts/QUICK-REFERENCE.md)\r\n\r\n[listserv response](https://lists.w3.org/Archives/Public/ietf-http-wg/2023JulSep/0131.html)",
          "createdAt": "2023-08-18T16:54:30Z",
          "updatedAt": "2023-08-18T16:54:30Z"
        },
        {
          "author": "royfielding",
          "authorAssociation": "NONE",
          "body": "I get really nervous when I see shell syntax mixed with URI syntax as a form of pattern matching. We usually don't do that on servers. Regular expression syntax is an even bigger foot gun, but we already have that implemented. Alternatively, the URI Template syntax is a form of pattern matching that is more specific than a wildcard.\r\n\r\nIf prefix/suffix is insufficient, then maybe \"contains\" could be there as well, though I'd seriously question why a site would want this much flexibility.",
          "createdAt": "2023-08-28T23:40:08Z",
          "updatedAt": "2023-08-28T23:40:08Z"
        },
        {
          "author": "pmeenan",
          "authorAssociation": "OWNER",
          "body": "@royfielding Not sure that it helps any, but the server wouldn't be doing any path matching. It just provides the path string as a hint to the client for where the dictionary would be usable (doesn't need to be validated on the server side at request time - no harm if a resource outside of the path is compressed).\r\n\r\nI'll do some browsing over the next week or so and build up a library of URL patterns for static resources and \"similar\" HTML pages and see what things look like in the wild.",
          "createdAt": "2023-08-29T18:43:17Z",
          "updatedAt": "2023-08-29T18:43:17Z"
        },
        {
          "author": "pmeenan",
          "authorAssociation": "OWNER",
          "body": "Closing. Moved to httpwg repository ^",
          "createdAt": "2023-09-20T20:05:08Z",
          "updatedAt": "2023-09-20T20:05:08Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "I_kwDOJ1PnBs5ur1g7",
      "title": "Match URLs should not allow full URLs - Raised by Ilari Liusvaara",
      "url": "https://github.com/pmeenan/i-d-compression-dictionary/issues/2",
      "state": "CLOSED",
      "author": "pmeenan",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Allowing absolute URLs in match is a footgun, since dictionaries are  restricted to same-origin. I don't think any of the usual URI  productions are suitable here.\r\n\r\nI think most suitable would be 'segment *( \"/\" segment )', where  segment is the production from RFC 3986.\r\n\r\n[Original listserv response](https://lists.w3.org/Archives/Public/ietf-http-wg/2023AprJun/0309.html)",
      "createdAt": "2023-08-18T16:26:49Z",
      "updatedAt": "2023-09-20T20:02:03Z",
      "closedAt": "2023-09-20T20:02:03Z",
      "comments": [
        {
          "author": "pmeenan",
          "authorAssociation": "OWNER",
          "body": "Even though the URLs must be same-origin, there's some benefit to allowing arbitrary URL formatting to allow for the clean use of relative URLs. They are all going to be expanded to absolute URLs anyway and it wouldn't break anything if someone chose to include the protocol and host parts (though there's no benefit to sending them).\r\n\r\n[Original listserv response](https://lists.w3.org/Archives/Public/ietf-http-wg/2023AprJun/0312.html)",
          "createdAt": "2023-08-18T16:29:01Z",
          "updatedAt": "2023-08-18T16:29:01Z"
        },
        {
          "author": "pmeenan",
          "authorAssociation": "OWNER",
          "body": "Closing. Moved to the httpwg repository ^",
          "createdAt": "2023-09-20T20:02:03Z",
          "updatedAt": "2023-09-20T20:02:03Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDOJ1PnBs5ur3m5",
      "title": "Response should include dictionary used for encoding - raised by Martin Thomson",
      "url": "https://github.com/pmeenan/i-d-compression-dictionary/issues/3",
      "state": "CLOSED",
      "author": "pmeenan",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "I don't understand how a client determines which dictionary was used by the server.  It seems like the response depends on the request, which is fragile (and doesn't allow clients to advertise multiple dictionaries, which seems likely with Use-As-Dictionary as it is).\r\n\r\n[Original listserv response](https://lists.w3.org/Archives/Public/ietf-http-wg/2023JulSep/0102.html)\r\ncc @martinthomson",
      "createdAt": "2023-08-18T16:34:40Z",
      "updatedAt": "2023-09-20T19:49:41Z",
      "closedAt": "2023-09-20T19:49:41Z",
      "comments": [
        {
          "author": "pmeenan",
          "authorAssociation": "OWNER",
          "body": "For identifying the dictionary, it's worth noting that the spec requires that the client advertise a SINGLE dictionary that it supports but yes, the response depends on the dictionary identified in the request. This also helps with minimizing the variants that caches would need to store since the response needs to be varied on the request's available dictionary (and multiple would explode the permutations).  It wouldn't hurt to echo the dictionary hash in the response which would allow for other mechanisms of advertising dictionaries but that also carries the cost of complicating the vary logic (would need to vary based on whatever request header was used to negotiate the dictionary that ended up being used).\r\n\r\n[Listserv response](https://lists.w3.org/Archives/Public/ietf-http-wg/2023JulSep/0104.html)",
          "createdAt": "2023-08-18T16:35:33Z",
          "updatedAt": "2023-08-18T16:35:33Z"
        },
        {
          "author": "pmeenan",
          "authorAssociation": "OWNER",
          "body": "Closing. Moved to httpwg repository ^",
          "createdAt": "2023-09-20T19:49:41Z",
          "updatedAt": "2023-09-20T19:49:41Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDOJ1PnBs5ur4Q5",
      "title": "Remove the Sec- prefix from Sec-Available-Dictionary - Raised by Martin Thomson",
      "url": "https://github.com/pmeenan/i-d-compression-dictionary/issues/4",
      "state": "CLOSED",
      "author": "pmeenan",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "The Sec- prefix seems entirely unjustified.  Yes, JS that can inject the field into a fetch might spoil a response (see above), but that's already true.  I'd prefer not to include Sec- prefixes unless there is clear justification.\r\n\r\n[Original listserv response](https://lists.w3.org/Archives/Public/ietf-http-wg/2023JulSep/0102.html)\r\ncc: @martinthomson",
      "createdAt": "2023-08-18T16:37:10Z",
      "updatedAt": "2023-08-31T17:53:44Z",
      "closedAt": "2023-08-31T17:53:44Z",
      "comments": [
        {
          "author": "pmeenan",
          "authorAssociation": "OWNER",
          "body": "It's unlikely that any harm/breakage that isn't self-inflicted would happen if it wasn't there and it wouldn't expose private information if it weren't and was abused since the responses are not opaque but since the dictionary selection and usage is handled entirely at the transport layer and transparent to fetch there's also minimal benefit to making it writable from the application code. It's not a hard requirement though so either way works.\r\n\r\n[Listserv response](https://lists.w3.org/Archives/Public/ietf-http-wg/2023JulSep/0104.html)",
          "createdAt": "2023-08-18T16:37:53Z",
          "updatedAt": "2023-08-18T16:37:53Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "To be clear, I don't want the standard for use of `sec-` prefixes to be \"maybe it's safer\".  We should be able to identify the threat that it mitigates and have no better way of managing the associated risk.  If this is \"either way works\", then we can drop the prefix and save the bytes.",
          "createdAt": "2023-08-18T17:50:26Z",
          "updatedAt": "2023-08-18T17:50:26Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDOJ1PnBs5ur42H",
      "title": "Split into two documents - Raised by Martin Thomson",
      "url": "https://github.com/pmeenan/i-d-compression-dictionary/issues/5",
      "state": "CLOSED",
      "author": "pmeenan",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Would it be worth considering a split for Use-As-Dictionary?  Or do we just need more information?  I have far less confidence in that component myself.\r\n\r\nIf this all stays as experimental, a single document is fine.  However, if delta encoding ends up being a slam dunk and we need more information on Use-As-Dictionary, then it might be good to take delta encoding as a proposed standard and leave Use-As-Dictionary as an experiment.\r\n\r\n[Original listserv response](https://lists.w3.org/Archives/Public/ietf-http-wg/2023JulSep/0103.html)\r\ncc @martinthomson",
      "createdAt": "2023-08-18T16:39:12Z",
      "updatedAt": "2023-09-20T19:53:43Z",
      "closedAt": "2023-09-20T19:53:42Z",
      "comments": [
        {
          "author": "pmeenan",
          "authorAssociation": "OWNER",
          "body": "It could make sense since setting the dictionary in a response doesn't have to be the only way that client's populate available dictionaries but the dictionary selection is somewhat entangled with the subsequent request.\r\n\r\nThere's a good chance that fields will need to be added to Use-As-Dictionary (I just added \"type\", for example, to allow for forward-compatibility with non-raw dictionaries) but some of those changes will also cascade to the content encoding. Zstandard-specific or Brotli-specific dictionary formats, for example, would require new content encodings as well as some explanation for what to send in the Accept-Encoding when using format-specific dictionaries.\r\n\r\n[listserv response](https://lists.w3.org/Archives/Public/ietf-http-wg/2023JulSep/0104.html)",
          "createdAt": "2023-08-18T16:40:12Z",
          "updatedAt": "2023-08-18T16:40:12Z"
        },
        {
          "author": "pmeenan",
          "authorAssociation": "OWNER",
          "body": "Closing. Moved to httpwg repository ^",
          "createdAt": "2023-09-20T19:53:43Z",
          "updatedAt": "2023-09-20T19:53:43Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDOJ1PnBs5ur520",
      "title": "Sould not use Content-encoding - Raised by Roy T. Fielding",
      "url": "https://github.com/pmeenan/i-d-compression-dictionary/issues/6",
      "state": "CLOSED",
      "author": "pmeenan",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "I think implementation of such through content-codings is fundamentally misguided because it changes the resource itself and impacts all caching along the chain of requests in ways that are non-recoverable. That is due to the lost metadata and variance on whatever request field is used to indicate that some downstream client can grok some possible dictionary.\r\n\r\nIn short, it looks like an easy solution for a browser, but will wreak havoc with the larger architecture of the Web.\r\n\r\nThe right way to do this is to implement it as a transfer encoding that can be decoded without loss or confusion with the unencoded resource, which would require extending h2 and h3 to support that feature of HTTP/1.1.\r\n\r\n[Original listserv response](https://lists.w3.org/Archives/Public/ietf-http-wg/2023JulSep/0130.html)\r\ncc @royfielding",
      "createdAt": "2023-08-18T16:43:07Z",
      "updatedAt": "2023-09-20T19:48:09Z",
      "closedAt": "2023-09-20T19:48:08Z",
      "comments": [
        {
          "author": "pmeenan",
          "authorAssociation": "OWNER",
          "body": "The decoded version of the resource is unchanged. It's not fundamentally different than brotli which happens to include a default dictionary and the caching is guaranteed to be maintained in a consistent way as long as \"Vary\" works on \"Accept-Encoding\" as well as whatever header negotiates the dictionary.\r\n\r\nEven without the dictionary, if something in the middle doesn't know how to process one of the content-encodings (and needs to be able to access the content) then the accept-encoding should be modified to only include encodings that it knows how to work with.\r\n\r\nThis isn't really notably different than \"br\" or \"zstd\".\r\n\r\nMoving the compression down into the transport layer is what we tried before but failed to navigate the browser security issues because the transport layer doesn't have the context of which responses need to be opaque, which responses are partitioned across document or frame boundaries, etc and that the dictionary compression could be used to perform oracle attacks across those boundaries.\r\n\r\n[listserv response](https://lists.w3.org/Archives/Public/ietf-http-wg/2023JulSep/0131.html)",
          "createdAt": "2023-08-18T16:49:30Z",
          "updatedAt": "2023-08-18T16:51:03Z"
        },
        {
          "author": "pmeenan",
          "authorAssociation": "OWNER",
          "body": "Closing. Moved to httpwg repository ^",
          "createdAt": "2023-09-20T19:48:08Z",
          "updatedAt": "2023-09-20T19:48:08Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOJ1PnBs5ur6kC",
      "title": "CORS is inappropriate - Raised by Roy T. Fielding",
      "url": "https://github.com/pmeenan/i-d-compression-dictionary/issues/7",
      "state": "CLOSED",
      "author": "pmeenan",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "For the existing draft, there is a lot of unnecessary confusion regarding features of fetch, like CORS, that don't make any sense from a security perspective. That's not what CORS is capable of covering, nor how it is implemented in practice, so reusing it doesn't make any sense. \r\n\r\n[Original listserv response](https://lists.w3.org/Archives/Public/ietf-http-wg/2023JulSep/0130.html)\r\ncc @royfielding",
      "createdAt": "2023-08-18T16:45:34Z",
      "updatedAt": "2023-09-20T19:45:23Z",
      "closedAt": "2023-09-20T19:45:23Z",
      "comments": [
        {
          "author": "pmeenan",
          "authorAssociation": "OWNER",
          "body": "CORS covers privacy from a browser perspective as far as the readability of responses relative to the origin of the containing document which is exactly the context that it is needed for here.\r\n\r\nThe concern that it takes care of is to make sure that responses that shouldn't be readable from the document context of the client can't be exposed to oracle timing attacks (because there won't be any client-opaque responses).\r\n\r\nHTTP itself doesn't really have the same document framing context and need for protecting read access of individual responses on a shared connection by clients running in different document contexts.\r\n\r\n[listserv response](https://lists.w3.org/Archives/Public/ietf-http-wg/2023JulSep/0131.html)",
          "createdAt": "2023-08-18T16:50:11Z",
          "updatedAt": "2023-08-18T16:50:11Z"
        },
        {
          "author": "royfielding",
          "authorAssociation": "NONE",
          "body": "I still don't see how CORS applies to the draft.\r\n\r\nIf the origin is choosing both the available dictionaries and whether or not to apply them to a given response, why is the context of a request relevant to the nature or credibility of the compressed response? Neither one is controlled by the context. The origin server isn't going to attack itself. The client might choose not to advertise an available dictionary based on the context, but I don't see how ignoring a server's valid response makes a difference.\r\n\r\nI assume the content of the response after decompressions would still be restricted by CORS, but that should already be defined by fetch; I wouldn't expect this document to specify it.",
          "createdAt": "2023-08-29T00:20:44Z",
          "updatedAt": "2023-08-29T00:20:44Z"
        },
        {
          "author": "pmeenan",
          "authorAssociation": "OWNER",
          "body": "The concern raised by the security team is that a client could abuse dictionary compression and a timing attack to expose the contents of a CORS-opaque response.  The contents themselves would already be prevented from being exposed directly but there's a theoretical risk that an origin serving private data through dictionary compression could expose that data unexpectedly in a cross-origin timing attack.\r\n\r\nI don't know enough about the practicality of timing-based oracle attacks using dictionary compression and the level of control that an attacker would need to have on either the payload of the response or the payload of the dictionary but in an abundance of caution we are recommending that servers avoid the problem entirely and don't use dictionaries in cross-origin opaque responses (even if it would be blocked from being processed in the client).",
          "createdAt": "2023-08-29T01:21:27Z",
          "updatedAt": "2023-08-29T01:21:27Z"
        },
        {
          "author": "pmeenan",
          "authorAssociation": "OWNER",
          "body": "Closing. Moved to httpwg repository ^",
          "createdAt": "2023-09-20T19:45:23Z",
          "updatedAt": "2023-09-20T19:45:23Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOJ1PnBs5ur7AE",
      "title": "Dictionary and compressed resource should be same-origin - Raised by Roy T. Fielding",
      "url": "https://github.com/pmeenan/i-d-compression-dictionary/issues/8",
      "state": "CLOSED",
      "author": "pmeenan",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Allowing a response from one origin to define a compression dictionary for responses received from some other origin would clearly violate the assumptions of https in so many ways (space, time, and cross-analysis). I don't see how we could possibly allow that even if both origins were covered by the same certificate. It would be far easier to require that everything have the same origin (as defined in RFC9110, not fetch) or by having the response origin define specifically which dictionary is being used (identifying both the dictionary URL and hash).  In the latter case, it would be possible to pre-define common dictionaries and thus reduce or remove the need to download them.\r\n\r\n[Original listserv response](https://lists.w3.org/Archives/Public/ietf-http-wg/2023JulSep/0130.html)\r\ncc @royfielding",
      "createdAt": "2023-08-18T16:47:17Z",
      "updatedAt": "2023-08-18T16:53:22Z",
      "closedAt": "2023-08-18T16:53:22Z",
      "comments": [
        {
          "author": "pmeenan",
          "authorAssociation": "OWNER",
          "body": "Maybe we crossed wires somewhere, but the dictionaries and the responses they apply to MUST be same-origin to each other in this ID. Where CORS comes into play is the dictionary or compressed response's relation to the document context that they are being fetched from (in a browser case anyway).\r\n\r\n[listserv response](https://lists.w3.org/Archives/Public/ietf-http-wg/2023JulSep/0131.html)\r\n\r\nClosing this because I believe that's already the case.\r\n\r\nFrom [2.1.1 match](https://www.ietf.org/archive/id/draft-meenan-httpbis-compression-dictionary-05.html#name-match):\r\n```\r\nThe Origin of the URL in the \"match\" pattern MUST be the same as the origin of the request that specifies the \"Use-As-Dictionary\" response and MUST not include a * wildcard.\r\n```",
          "createdAt": "2023-08-18T16:53:22Z",
          "updatedAt": "2023-08-18T16:53:22Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "I_kwDOJ1PnBs5ur9zF",
      "title": "Add dictionary URL to sec-available-dictionary requests - Raised by Vlad Krasnov",
      "url": "https://github.com/pmeenan/i-d-compression-dictionary/issues/9",
      "state": "CLOSED",
      "author": "pmeenan",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "I think it would make the proposal easier to support from a CDN POV if the Sec-Available-Dictionary included the dictionary URL and Etag, otherwise it requires too much state keeping.\r\n\r\nGiven a URL and an Etag it is pretty easy to have a best effort dictionary compression.\r\n\r\n[Original listserv response](https://lists.w3.org/Archives/Public/ietf-http-wg/2023JulSep/0091.html)\r\ncc @vkrasnov",
      "createdAt": "2023-08-18T16:57:53Z",
      "updatedAt": "2023-09-20T19:33:27Z",
      "closedAt": "2023-09-20T19:33:27Z",
      "comments": [
        {
          "author": "pmeenan",
          "authorAssociation": "OWNER",
          "body": "That would necessarily couple the use of a dictionary with the negotiation of the storage. They way it is currently set up, \"use-as-dictionary\" is one way to populate the dictionary but the dictionaries could also be pre-loaded into a client or otherwise negotiated.\r\n\r\nAs far as state, if you're passively observing traffic to compress and not actively managing the dictionaries, doesn't something like this work?\r\n\r\n1. See response with \"use-as-dictionary\" response header\r\n2. Store dictionary in key-value store, using the hash of the payload as\r\nthe key\r\n3. See request with \"sec-available-dictionary\" request header\r\n\r\nFor supporting static, offline resource compression:\r\n* If a version of the resource is in cache compressed with the requested dictionary, serve it\r\n* If not, kick off an async task to compress the cached full response with the dictionary (if one is available in KV)\r\n\r\nFor dynamic responses:\r\n* If the dictionary is in KV, use it to compress the response\r\n\r\nThe main \"state\" that needs to be managed is the storage of the dictionary keys, indexed by the appropriate hash.\r\n\r\nIf the CDN is generating the dictionaries (or adding the headers) there's not much more state than that either.\r\n\r\nI'm sure I'm probably hand-waving a lot of things that need to be done at scale when handling thousands of dictionaries and thousands of simultaneous requests for the same dictionary but I'd hate to add complexity to the negotiation itself if it isn't absolutely necessary.\r\n\r\n[listserv response](https://lists.w3.org/Archives/Public/ietf-http-wg/2023JulSep/0092.html)",
          "createdAt": "2023-08-18T16:59:25Z",
          "updatedAt": "2023-08-18T16:59:25Z"
        },
        {
          "author": "pmeenan",
          "authorAssociation": "OWNER",
          "body": "One area I could see benefitting from reducing some overhead would be around the hash of the dictionary contents since it could be expensive to calculate.\r\n\r\nOne thing we could do there is have an additional (optional) field in the use-as-dictionary response where the origin could populate the hash as \"hint\" so caches or clients could use the advertised hash to determine if it needs to store the dictionary or if it already has it.\r\n\r\nThe language would have to be careful to require that the actual hash still be calculated before storing (or use) to be sure that the has represents the contents accurately but the hint could make the processing lighter weight, particularly in the CDN flow.\r\n\r\n[listserv response](https://lists.w3.org/Archives/Public/ietf-http-wg/2023JulSep/0093.html)",
          "createdAt": "2023-08-18T17:00:23Z",
          "updatedAt": "2023-08-18T17:00:23Z"
        },
        {
          "author": "pmeenan",
          "authorAssociation": "OWNER",
          "body": "[listserv response](https://lists.w3.org/Archives/Public/ietf-http-wg/2023JulSep/0094.html) from @vkrasnov:\r\n\r\nThere are many possible architectures that can work of course, but the simplest one and most generic one is to hope the dictionary is present in your local cache and fetch it (with Cache-Control: only-if-cached; If-Match: etag).\r\n\r\nI would definitely avoid using a KV for a generic solution, maybe in the far future for high value use case.\r\n\r\nI can't simply store an arbitrary number of dictionaries in KV, this can very well explode, and some intelligent eviction is needed.\r\n\r\nWe also don't want to store multiple versions of the same resource compressed with different algorithms, even for statically compressed assets. It consumes valuable space that could be used to cache other assets instead.\r\n\r\nIn any case, having the URL and ETag (and obviously ETags are not always present either) allows us to have *something* in production almost out of the box, having just the cache requires building new stuff, which is a much higher bar for entrance.\r\n",
          "createdAt": "2023-08-18T17:01:12Z",
          "updatedAt": "2023-08-18T17:01:12Z"
        },
        {
          "author": "pmeenan",
          "authorAssociation": "OWNER",
          "body": "I have a few concerns with making the URL available (for URL-delivered dictionaries).  It's possible we could add another optional header as a request hint but there's a risk of middle-boxes holding it wrong.\r\n\r\n* You would still need to verify that the hash of the dictionary matches the requested hash before using it. Re-calculating the hash on every access could be pretty expensive (feels like verifying the hash before writing would be hit less often).\r\n* The same URL could represent multiple dictionaries with different hashes (think a well-known URL like fb.js that does in-place upgrades).\r\n\r\nIndexing the entry by URL and hash could potentially solve the issues but could it not just as easily be indexed by the hash without the URL since the hash is the unique index?",
          "createdAt": "2023-08-18T17:01:59Z",
          "updatedAt": "2023-08-18T17:01:59Z"
        },
        {
          "author": "pmeenan",
          "authorAssociation": "OWNER",
          "body": "Moved to httpwg repository ^",
          "createdAt": "2023-09-20T19:33:27Z",
          "updatedAt": "2023-09-20T19:33:27Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOJ1PnBs5wrFam",
      "title": "Test - migrate",
      "url": "https://github.com/pmeenan/i-d-compression-dictionary/issues/10",
      "state": "CLOSED",
      "author": "pmeenan",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Test issue for Kamino issue cloning",
      "createdAt": "2023-09-11T11:54:35Z",
      "updatedAt": "2023-09-20T19:28:06Z",
      "closedAt": "2023-09-20T19:28:06Z",
      "comments": []
    }
  ],
  "pulls": []
}